#include <iostream>
using namespace std;
int n, kol, c, m, temp = 0, temp2, temp3, // n - общее количество гвоздей, kol количество компаний - 1, так как первая не задействуется,
loctep, g, a, i, j; // c - завод, а так же минимальное кол во маркировок, данного завода, m - маркировка, temp предыдущие значение массива, temp3 - предыдущие значение массива,
int main()			// temp2-предыдущие значение массива на уровне массивов, loctep-значение если нельзя собрать несколько маркировок, 
{					// g - кол во одинаковых маркировок, a - условие исстинности, i и g - счетчики циклов

	const int comp = 9, mark = 10; //максимальное кол во компаний(заводов) и маркировок
	int gvozd[comp][mark]; // двойной массив
	cin >> n;
	cin >> kol;
    //данный блок двойного цикла считывает завод который занимается упоковкой гвоздей по маркировкам
	for (int i = 1; i < kol; i++)
	{
		cin >> c;
		for (int j = 0; j < c; j++) //эта часть считывает маркировку, т.е кол во гвоздей в коробке и заносит их в массив
		{
			cin >> m; // маркировка и состовляющая второго массива
			gvozd[i][j] = m;
		}
	}
	//данный  двойной цикл ведет проверку
	for (int i = 1; i < comp; i++)
	{
		//данный блок двойного цикла введет учет внутри второго массива и выявляет наиболее подходящий выриант
		for (int j = 0; j < mark; j++)
		{
			g = n / gvozd[i][j];
			if (g == 1) 
			{									// это ветвление проверяет,
				if (gvozd[i][j] <= n)			//если нельзя из нескольких коробок сложить одну для следующего завода
					loctep += gvozd[i][j];		//он ее заносит в переменную для дальнейшего использования
				if (loctep <= n)				//если данная переменная меньше или равна нужному количеству
					if (loctep >= temp)			//и больше или равна предыдущему значению
						temp = loctep;			//оно переписывается заместу старому
			}
			if (g > 1)									// это ветвление проверяет, 
				if (gvozd[i][j] * g <= n)				//можно ли собрать нужное количество из нескольких коробок
					if (temp <= n)						// и если да, то из скольких
						temp = gvozd[i][j] * g;
			
			if (temp < gvozd[i][j])				//тут же проверяется возможность собрать нужное колво
				a = 1;							//если маркировка меньше нужного кол ва, то ставит
			else                                //если наоборот то ноль
				a = 0;
			if (j == 1)							// данное выражение при изначальном отсчете 
				temp3 = temp;					// ставит предыдущее значение равное данному
			
				if (temp > temp3)				//если предыдущее значение меньше нынешнего, то меньшее перезаписывается
					temp3 = temp;
		}
		//данный блок ведет проверку между массивами массивов, temp 2 - значение предыдущего масива, temp - текущего
		if (i == 1) //при первой итерации значения совпадают
			temp2 = temp;
		if (temp >= temp2) // если значение текущего больше предыдущего то оно переписывается
			temp2 = temp;
		n = temp2; // нужное количество может совпадать, но и может немного отличаться
	}
	if (n==0) //если количество гвоздей стало нулем значит невозможно собрать
		cout << "Impos";
	if (a == 0)     // тут идет ветвление от того, если маркировка в конце итерации не стала больше нужного количество  
		cout << n;  //и нет ошибок ставим 0, и выводится итоговое кол во гвоздей, которое могут предоставить
	else			// если другте не предвиденные ошибки то собрать тоже невозможно
		cout << "Impos";
}
